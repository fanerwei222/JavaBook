

## 四种引用
            ~~~|  Java4种引用的级别由高到低依次为：  |~~~
                强引用  >  软引用  >  弱引用  >  虚引用

### 1.强引用 ：只要引用存在，垃圾回收器永远不会回收
                Object o = new Object("cat");   //  强引用
                以上代码就是 变量o指向了一个叫cat的Object对象的实例，这里就是强引用。
                
                如果你不需要使用某个对象了，可以将相应的引用设置为null，消除强引用来帮助垃圾回收器进行回收。因为过多的强引用也是导致OOM的罪魁祸首。
                o = null;
                显式地设置消除引用，或已超出对象的生命周期范围，则JVM会认为该对象不存在引用，这时就可能会回收这个对象。
                但是具体什么时候收集这要取决于具体的GC算法。
                
                如果在一个方法的内部有一个变量s持有一个对象（Object）的强引用，
                那么这个变量s保存在栈中，
                而真正的引用内容（object）保存在堆中。
                当这个方法运行完成后就会退出方法栈，
                则引用s也会被销毁，这个object就会被回收。
                但是当这个s是全局变量时，就需要在不再使用这个对象时赋值为null，
                因为有强引用关联的对象是不会被垃圾回收的。
                
                例如下面这个代码是会造成内存泄漏的
                A a = new A();
                B b = new B(a);
                a = null;
                a 拿着 A对象实例的强引用，然后又把A对象实例给B，
                相当于是把它给B之后自己就跑了，还对JVM说我不要A对象的实例了，你快去销毁吧。
                但是这个时候B是拿着A对象实例的，所以这里就会出现问题。
                
                下面这个例子也会出现内存泄漏
                public static ArrayList<Object> list = new ArrayList<Object>();
                public void stackOverflowTest(Object object){
                    list.add(object);
                    object = null;
                    //list还需要object这里就设置成了null，消除了object对Object对象实例的强引用。
                    //那么GCC的时候object可能就不存在了，那么list将不能正确获得object。
                }

### 2.弱引用

### 3.软引用

### 4.虚引用
